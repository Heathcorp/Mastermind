// #include <bitops>
#include <i8>

struct u16 {
  cell n0;
  cell n1;
}

fn _65535(struct u16 n) {
  n.n0 = 255;
  n.n1 = 255;
}
fn MAX(struct u16 n) {_65535(n);}
fn _10(struct u16 n) {
  n.n0 = 10;
  n.n1 = 0;
}
fn _100(struct u16 n) {
  n.n0 = 100;
  n.n1 = 0;
}
fn _1000(struct u16 n) {
  n.n0 = 232;
  n.n1 = 3;
}
fn _1024(struct u16 n) {
  n.n0 = 0;
  n.n1 = 4;
}
fn _2048(struct u16 n) {
  n.n0 = 0;
  n.n1 = 8;
}
fn _4096(struct u16 n) {
  n.n0 = 0;
  n.n1 = 16;
}
fn _8192(struct u16 n) {
  n.n0 = 0;
  n.n1 = 32;
}
fn _10000(struct u16 n) {
  n.n0 = 16;
  n.n1 = 39;
}
fn _16384(struct u16 n) {
  n.n0 = 0;
  n.n1 = 64;
}
fn _20000(struct u16 n) {
  n.n0 = 32;
  n.n1 = 78;
}

/// copy one u16 into another
fn cpy(struct u16 src, struct u16 dest) {
  dest.n0 = src.n0;
  dest.n1 = src.n1;
}

/// increment a u16 by 1
fn inc(struct u16 self) {
  self.n0 += 1;
  self.n1 += 1;
  if self.n0 {
    self.n1 -= 1;
  }
  // more efficient version of the following:
  // if not self.n0 {
  //   self.n1 += 1;
  // }
}

/// decrement a u16 by 1
fn dec(struct u16 self) {
  self.n1 -= 1;
  if self.n0 {
    self.n1 += 1;
  }
  self.n0 -= 1;
}

/// add a cell's value as a u8 in place to the current u16
fn add(struct u16 self, cell other) {
  copy other {
    inc(self);
  }
}
/// overload for an i8 (signed 8-bit)
fn add(struct u16 self, struct i8 other) {
  cell abs;
  cell neg;
  to_u8(other, abs, neg);

  if not neg {
    drain abs {
      inc(self);
    }
  } else {
    drain abs {
      dec(self);
    }
  }
  assert abs equals 0;
}
/// overload for another u16
fn add(struct u16 self, struct u16 other) {
  // most significant first
  copy other.n1 {
    self.n1 += 1;
    self.n0 += 1;
    if self.n1 {
      self.n0 -= 1;
    }
  }
  copy other.n0 {
    self.n0 += 1;
    self.n1 += 1;
    if self.n0 {
      self.n1 -= 1;
    }
  }
}

/// check if number is non-zero
fn ne_zero(struct u16 self, cell _output) {
  // return n0 || n1
  if self.n0 {
    _output = true;
  }
  if self.n1 {
    _output = true;
  }
}

/// print the u16 as a base-10 natural number [0, 65535]
fn print(struct u16 self) {
  struct DS {
    // markers either side of the digit stack
    // cell m0 @0;
    cell[5] stack;
    // cell m1 @6;
  }
  struct DS ds;
  fn shift_stack() {
    ds.stack[4] = 0;
    drain ds.stack[3] into ds.stack[4];
    drain ds.stack[2] into ds.stack[3];
    drain ds.stack[1] into ds.stack[2];
    drain ds.stack[0] into ds.stack[1];
  }
  fn unshift_stack() {
    ds.stack[0] = 0;
    drain ds.stack[1] into ds.stack[0];
    drain ds.stack[2] into ds.stack[1];
    drain ds.stack[3] into ds.stack[2];
    drain ds.stack[4] into ds.stack[3];
  }
  fn debug_stack() {
    output '0' + ds.stack[0];
    output '0' + ds.stack[1];
    output '0' + ds.stack[2];
    output '0' + ds.stack[3];
    output '0' + ds.stack[4];
  }

  struct u16 n;
  cpy(self, n);
  // essentially repeatedly divide by 10
  drain 5 {
    shift_stack();
    cell dividing = true;
    struct u16 m;// MAX(m); // quotient set to -1 = 65535
    ds.stack[0] = 10; // remainder, add 1 for magic later on
    while dividing {
      drain 10 {
        cell o; ne_zero(n, o);
        if o {
          dec(n);
        } else {
          ds.stack[0] -= 1;
          dividing = false;
        }
      }

      if dividing {
        inc(m);
      }
    }
    // copy new quotient to value so we start again
    cpy(m, n);
  }

  cell not_leading = false;
  drain 5 {
    if ds.stack[0] {
      not_leading = true;
    }
    if not_leading {
      ds.stack[0] += '0';
      output ds.stack[0];
    }
    unshift_stack();
  }
}

// debug/test code:
// #include "print.mmi"
// struct u16 a; // = 0
// MAX(a);

// print(a);
// output '\n';

// drain 100 {
//   drain 100 {
//     inc(a);
//     print(a);
//     output '\n';
//   }
// }
// struct u16 a;
// _100(a);
// print(a);
// output '\n';
// _1000(a);
// print(a);
// output '\n';
// _10000(a);
// print(a);
// output '\n';
// _20000(a);
// print(a);
// output '\n';
// struct u16 a;
// struct u16 b;
// _100(a);
// _1000(b);
// add(a, b);
// print(a); output '\n';
// _16384(b);
// add(a, b);
// print(a); output '\n';