struct stack32 { // STACK CANNOT CONTAIN ZEROES.
  cell len;
  cell zero;
  cell[32] content;
  cell end; // if this is not equal to zero, panic.
}

// DOCUMENTATION

// struct stack32 - 32-cell stack; uses 35 cells.

// push_d(stack, value)    - push a value destructively to the stack.
// push(stack, value)      - push a value to the stack. slower than push_d
// unshift_d(stack, value) - push a value destructively into the bottom of the stack.
// unshift(stack, value)   - push a value into the bottom of the stack.

// pop(stack, *output)   - pop a value from the stack.
// shift(stack, *output) - shift a value from the bottom of the stack.
// shift is faster than pop.

// reverse(stack) - reverses the stack.
// clear(stack)   - clears the stack. Suggested if a stack is about to go out of scope.


fn __move_to_top(struct stack32 stack) {
  bf @stack.zero clobbers *stack.content {
    >[>]<
  }
}

fn __back_to_zero() {
  bf {
    [<]
  }
}

fn push_d(struct stack32 stack, cell value) {
  value -= 1;
  stack.len += 1;
  bf @stack.zero clobbers *stack.content {
    >[>]+
  }
  __back_to_zero();
  while value {
    value -= 1;
    __move_to_top(stack);
    bf clobbers *stack.content {+}
    __back_to_zero();
  }
}

fn push(struct stack32 stack, cell value) {
  cell _value = value;
  push_d(stack, _value);
}


fn pop(struct stack32 stack, cell out) {
  stack.len -= 1;
  out = 0;
  bf @stack.zero {>[>]<[>+<-]>}
  bf { [-<< }
    __back_to_zero();
    out += 1;
    __move_to_top(stack);
  bf { >>]<< }
  __back_to_zero();
}

fn pop(struct stack32 stack) {
  stack.len -= 1;
  __move_to_top(stack);
  bf clobbers *stack.content {[-]<}
  __back_to_zero();
}

fn shift(struct stack32 stack, cell out) {
  out = 0;
  stack.len -= 1;
  drain stack.content[0] into out;
  bf @stack.content[1] clobbers *stack.content { [[<+>-]>]<<[<]>> }
}

fn shift(struct stack32 stack) {
  stack.len -= 1;
  bf @stack.content[1] clobbers *stack.content { [[<+>-]>]<<[<]>> }
}

fn unshift_d(struct stack32 stack, cell value) {
  stack.len += 1;
  __move_to_top(stack);
  bf clobbers *stack.content { [[->+<]<] }
  stack.content[0] = 0;
  drain value into stack.content[0];
}

fn unshift(struct stack32 stack, cell value) {
  cell _value = value;
  unshift_d(stack, value);
}

fn clear(struct stack32 stack) {
  while stack.len {
    pop(stack);
  }
  assert *stack.content equals 0;
}

fn move_stack(struct stack32 in, struct stack32 out) { // out must be empty
  cell x;
  while in.len {
    shift(in, x);
    push_d(out, x);
  }
  assert *in.content equals 0;
}

fn copy_stack(struct stack32 src, struct stack32 out) {
  cell x;
  struct stack32 _src;
  while src.len {
    shift(src, x);
    push(out, x);
    push_d(_src, x);
  }
  while _src.len {
    shift(_src, x);
    push_d(src, x);
  }
  assert *_src.content equals 0;
}

fn reverse(struct stack32 stack, struct stack32 out) { // out must be empty
  cell x;
  while stack.len {
    pop(stack, x);
    push_d(out, x);
  }
  assert *stack.content equals 0;
}

fn reverse(struct stack32 stack) {
  struct stack32 out;
  reverse(stack, out);
  move_stack(out, stack);
}











