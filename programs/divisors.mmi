// the purpose of this program is to print the divisors of the numbers 1 to 100
// from https://code.golf:
// A number is a divisor of another number if it can divide into it with no remainder.
// Print the positive divisors of each number from 1 to 100 inclusive, on their own line, with each divisor separated by a space. 

def divisible
  int[1] result
  int[1] dividend
  int[1] divisor
{
  // iteratively subtract divisor from dividend
  // if the result goes below zero, break out of the main loop once the subtraction is finished
  int[1] iterating 1
  copy result dividend
  while iterating
  {
    int[1] d
    copy d divisor
    loop d
    {
      // check if result is zero, if so we set iterating to 0
      if result
      {
      }
      else
      {
        clear iterating
      }

      // typical brainfuck draining addition/subtraction loop
      sub result 1
    }

    // check after inner loop as well
    if result
    {
    }
    else
    {
      clear iterating
    }
  }
  // result = dividend - divisor * ceil(dividend / divisor)
}

def print_num
  int[1] num
  int[1] const_100
  int[1] const_10
{
  int[1] hc
  int[1] tc
  // variable layout could be optimised, TODO: allocate sequentially rather than hoisting
  // will only print single byte positive numbers, nothing more than 999 (limited by 255 though)
  // this function is also not ideal and hacked together to make it work so don't judge
  int[1] zero_char 48

  int[1] hundreds -1
  int[1] tens -1
  int[1] ones

  int[1] iterating 1
  int[1] radix
  int[1] ones_copy

  copy ones_copy num
  while iterating
  {
    clear ones
    copy ones ones_copy

    add hundreds 1

    copy radix const_100
    loop radix
    {
      if ones_copy
      {
        sub ones_copy 1
      }
      else
      {
        clear iterating
      }
    }
  }

  copy ones_copy ones
  add iterating 1
  while iterating
  {
    clear ones
    copy ones ones_copy

    add tens 1

    copy radix const_10
    loop radix
    {
      if ones_copy
      {
        sub ones_copy 1
      }
      else
      {
        clear iterating
      }
    }
  }

  // make a copy of the variables before we add ascii 0
  copy hc hundreds
  copy tc tens

  // need some more sugar for this
  // add 48 to each of the cells
  loop zero_char
  {
    add hundreds 1
    add tens 1
    add ones 1
  }

  // maybe need some strings
  // TODO: implement stacks

  if hc consume
  {
    clear tc
    output hundreds
    output tens
  }
  if tc consume
  {
    output tens
  }
  output ones
  clear ones

  clear hundreds
  clear tens
}

// main
// dodgy multiplication to initialise variables quicker, TODO: make an algorithm for this?
int[1] n10 10
loop n10
{
  add n_iter 10
  add const_100 10
  add const_10 1
  add const_space 3
}
add const_space 2

int[1] n_iter // 100
int[1] const_100 // 100
int[1] const_10 // 10
int[1] const_space // 32

int[1] n
loop n_iter
{
  add n 1

  int[1] i
  int[1] i_iter
  copy i_iter n
  loop i_iter
  {
    int[1] divisible_result
    add i 1

    call divisible divisible_result n i
    if divisible_result consume
    {
    }
    else
    {
      // n % i == 0
      call print_num i const_100 const_10
      output const_space
    }
  }
  clear i

  output const_10
  // important! // TODO: add some sugar for variable consumption?
}