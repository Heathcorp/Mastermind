// the purpose of this program is to print the divisors of the numbers 1 to 100
// from https://code.golf:
// A number is a divisor of another number if it can divide into it with no remainder.
// Print the positive divisors of each number from 1 to 100 inclusive, on their own line, with each divisor separated by a space. 

def divisible
  int[1] result
  int[1] dividend
  int[1] divisor
{
  // iteratively subtract divisor from dividend
  // if the result goes below zero, break out of the main loop once the subtraction is finished
  int[1] iterating 1
  copy result dividend
  while iterating
  {
    int[1] d
    copy d divisor
    loop d
    {
      // if result is still positive, stay in outer loop
      sub iterating 1
      if result
      {
        add iterating 1
      }
      
      // typical brainfuck draining addition/subtraction loop
      sub result 1
    }
    free d

    sub iterating 1
    // check after inner loop as well
    if result
    {
      add iterating 1
    }
  }
  free iterating
  // result = dividend - divisor * ceil(dividend / divisor)
}

def print_num
  int[1] num
  int[1] const_100
  int[1] const_10
{
  int[1] tens -1
  int[1] hundreds -1
  int[1] ones

  bool iterating 1
  int[1] ones_copy

  copy ones_copy num
  while iterating
  {
    clear ones
    copy ones ones_copy

    add hundreds 1

    int[1] radix
    copy radix const_100
    loop radix
    {
      clear iterating
      if ones_copy
      {
        add iterating 1
        sub ones_copy 1
      }
    }
    free radix
  }
  free iterating

  copy ones_copy ones
  bool iterating 1
  while iterating
  {
    clear ones
    copy ones ones_copy

    add tens 1

    int[1] radix
    copy radix const_10
    loop radix
    {
      clear iterating
      if ones_copy
      {
        add iterating 1
        sub ones_copy 1
      }
    }
    free radix
  }
  free iterating
  free ones_copy


  int[1] tc
  int[1] hc
  copy hc hundreds
  copy tc tens

  // need some more sugar for multiplication
  // add 48 to each of the cells
  int[1] _twelve 12
  loop _twelve
  {
    add hundreds 4
    add tens 4
    add ones 4
  }
  free _twelve
  // need sugar for draining/copying into multiple variables
  // imagine instead: 
  // add hundreds tens ones | 48
  // or
  // add hundreds | 8 * 6

  // if hc consume // this particular consume if could be optimised only because the numbers in this program only go up to 100
  // {
  //   output hundreds
  //   output tens
  //   clear tc
  // }
  // optimisation hack
  while hc
  {
    sub hc 1
    output hundreds
    output tens
    clear tc
  }
  if tc consume
  {
    output tens
  }
  output ones
  clear ones
  clear hundreds
  clear tens
}

// main
// dodgy multiplication to initialise variables quicker, TODO: make an algorithm for this?


int[1] const_space 2 // 32
int[1] const_100 // 100
int[1] n_iter // 100
int[1] const_10 // 10

int[1] n10 10
loop n10
{
  add const_10 1
  add n_iter 10
  add const_100 10
  add const_space 3
}
free n10

int[1] n
loop n_iter
{
  add n 1

  int[1] i
  int[1] i_iter
  copy i_iter n
  loop i_iter
  {
    int[1] divisible_result
    add i 1

    call divisible divisible_result n i
    if divisible_result consume
    {
    }
    else
    {
      // n % i == 0
      call print_num i const_100 const_10
      output const_space
    }
  }
  clear i

  output const_10
  // important! // TODO: add some sugar for variable consumption?
}